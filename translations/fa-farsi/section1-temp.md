## بخش: ذهن خود را به چالش بکشید!

### ▶ اول از همه! *

<!-- Example ID: d3d73936-3cf1-4632-b5ab-817981338863 -->
<!-- read-only -->

به دلایلی، عملگر "Walrus" (`:=`) که در نسخه ۳.۸ پایتون معرفی شد، خیلی محبوب شده. بیاید بررسیش کنیم.

1\.

```py
# Python version 3.8+

>>> a = "wtf_walrus"
>>> a
'wtf_walrus'

>>> a := "wtf_walrus"
File "<stdin>", line 1
    a := "wtf_walrus"
      ^
SyntaxError: invalid syntax

>>> (a := "wtf_walrus") # ولی این کار می‌کنه
'wtf_walrus'
>>> a
'wtf_walrus'
```

2 \.

```py
# Python version 3.8+

>>> a = 6, 9
>>> a
(6, 9)

>>> (a := 6, 9)
(6, 9)
>>> a
6

>>> a, b = 6, 9 # باز کردن معمولی
>>> a, b
(6, 9)
>>> (a, b = 16, 19) # آخ آخ
  File "<stdin>", line 1
    (a, b = 16, 19)
          ^
SyntaxError: invalid syntax

>>> (a, b := 16, 19) # این یه تاپل ۳تایی چاپ می‌کنه رو صفحه
(6, 16, 19)

>>> a # هنوز تغییر نکرده؟
6

>>> b
16
```



#### 💡 توضیحات

**مرور سریع بر عملگر Walrus**

عملگر Walrus همونطور که اشاره شد، در نسخه ۳.۸ پایتون معرفی
شد. این عملگر می‌تونه تو مقعیت‌هایی کاربردی باشه که شما می‌خواید داخل یه عبارت، مقادیری رو به متغیرها اختصاص بدید

```py
def some_func():
        # فرض کنید اینجا یک سری محاسبه سنگین انجام میشه
        # time.sleep(1000)
        return 5

# پس به جای اینکه این کارو بکنید:
if some_func():
        print(some_func()) # که خیلی راه نادرستیه چون محاسبه دوبار انجام میشه

# یا حتی این کارو کنید (که کار بدی هم نیست)
a = some_func()
if a:
    print(a)

# می‌تونید از این به بعد به طور مختصر بنویسید:
if a := some_func():
        print(a)

```

**خروجی (+۳.۸):**

```py
5
5
5
```

این باعث میشه که یک خط کمتر کد بزنیم و از دوبار فراخوندن `some_func` جلوگیری کرد.

- "عبارت اختصاص‌دادن مقدار" بدون پرانتز (نحوه استفاده عملگر Walrus)، در سطح بالا محدود است، `SyntaxError` در عبارت `a := "wtf_walrus"` در قطعه‌کد اول به همین دلیل است. قرار دادن آن داخل پرانتز، همانطور که می‌خواستیم کار کرد و مقدار را به `a` اختصاص داد.

- به طور معمول، قرار دادن عبارتی که دارای `=` است داخل پرانتز مجاز نیست. به همین دلیل ‍عبارت `(a, b = 6, 9)` به ما خطای سینتکس داد.

- قائده استفاده از عملگر Walrus به صورت `NAME:= expr` است، به طوری که `NAME` یک شناسه صحیح و `expr` یک عبارت صحیح است. به همین دلیل باز و بسته کردن با تکرار (iterable) پشتیبانی نمی‌شوند. پس،

  - عبارت `(a := 6, 9)` معادل عبارت `((a := 6), 9)` و در نهایت `(a, 9)` است. (که مقدار `a` عدد 6 است)

    ```py
    >>> (a := 6, 9) == ((a := 6), 9)
    True
    >>> x = (a := 696, 9)
    >>> x
    (696, 9)
    >>> x[0] is a # هر دو به یک مکان در حافظه دستگاه اشاره می‌کنند
    True
    ```

  - به طور مشابه، عبارت `(a, b := 16, 19)` معادل عبارت `(a, (b := 16), 19)` است که چیزی جز یک تاپل ۳تایی نیست.

---

### ▶ بعضی وقت‌ها رشته‌ها می‌توانند دردسرساز شوند

<!-- Example ID: 30f1d3fc-e267-4b30-84ef-4d9e7091ac1a --->
1\.

```py
>>> a = "some_string"
>>> id(a)
140420665652016
>>> id("some" + "_" + "string") # دقت کنید که هردو شناسه یکسانند.
140420665652016
```

2\.
```py
>>> a = "wtf"
>>> b = "wtf"
>>> a is b
True

>>> a = "wtf!"
>>> b = "wtf!"
>>> a is b
False

```

3\.

```py
>>> a, b = "wtf!", "wtf!"
>>> a is b # همه‌ی نسخه‌ها به جز 3.7.x
True

>>> a = "wtf!"; b = "wtf!"
>>> a is b # ممکن است True یا False باشد بسته به جایی که آن را اجرا می‌کنید (python shell / ipython / به‌صورت اسکریپت)
False
```

```py
# این بار در فایل some_file.py
a = "wtf!"
b = "wtf!"
print(a is b)

# موقع اجرای ماژول، True را چاپ می‌کند!
```

4\.

**خروجی (< Python3.7 )**

```py
>>> 'a' * 20 is 'aaaaaaaaaaaaaaaaaaaa'
True
>>> 'a' * 21 is 'aaaaaaaaaaaaaaaaaaaaa'
False
```

منطقیه، نه؟

#### 💡 توضیحات:
+ در قطعه‌کد اول و دوم، رفتار کد به دلیل یک بهینه سازی در CPython است (به نام داوطلب سازی رشته‌ها) که باعث می‌شود از برخی مقادیر غیرقابل تغییر، به جای مقداردهی مجدد، دوباره استفاده شود.
+ بیشتر متغیرهایی که به‌این صورت جایگزین می‌شوند، در حافظه دستگاه به مقدار داوطلب خود اشاره می‌کنند (تا از حافظه کمتری استفاده شود)
+ در قطعه‌کدهای بالا، رشته‌ها به‌صورت غیرمستقیم داوطلب می‌شوند. تصمیم اینکه رشته‌ها چه زمانی به صورت غیرمستقیم داوطلب شوند به نحوه پیاده‌سازی و مقداردهی آن‌ها بستگی دارد. برخی قوانین وجود دارند تا بتوانیم داوطلب شدن یا نشدن یک رشته را حدس بزنیم:
  * همه رشته‌ها با طول صفر یا یک داوطلب می‌شوند.
  * رشته‌ها در زمان کامپایل داوطلب می‌شوند (`'wtf'` داوطلب می‌شود اما `''.join(['w', 't', 'f'])` داوطلب نمی‌شود)
  * رشته‌هایی که از حروف ASCII ، اعداد صحیح و آندرلاین تشکیل نشده‌باشند داوطلب نمی‌شود. به همین دلیل `'wtf!'` به خاطر وجود `'!'` داوطلب نشد. پیاده‌سازی این قانون در CPython در [اینجا](https://github.com/python/cpython/blob/3.6/Objects/codeobject.c#L19) قرار دارد.

<p align="center">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="/images/string-intern/string_interning_dark_theme.svg">
      <source media="(prefers-color-scheme: light)" srcset="/images/string-intern/string_interning.svg">
      <img alt="Shows a string interning process." src="/images/string-intern/string_interning.svg">
    </picture>
</p>

+ زمانی که `"wtf!"` را در یک خط به `a` و `b` اختصاص می‌دهیم، مفسر پایتون شیء جدید می‌سازد و متغیر دوم را به آن ارجاع می‌دهد. اگر مقدار دهی در خط‌های جدا از هم انجام شود، در واقع مفسر "خبر ندارد" که یک شیء مختص به `"wtf!"` از قبل در برنامه وجود دارد (زیرا `"wtf!"` به دلایلی که در بالا گفته شد، به‌صورت غیرمستقیم داوطلب نمی‌شود). این بهینه سازی در زمان کامپایل انجام می‌شود. این بهینه سازی همچنین برای نسخه های (x).۳.۷ وجود ندارد (برای گفت‌وگوی بیشتر این [موضوع](https://github.com/satwikkansal/wtfpython/issues/100) را ببینید).
+ یک واحد کامپایل در یک محیط تعاملی مانند IPython از یک عبارت تشکیل می‌شود، در حالی که برای ماژول‌ها شامل کل ماژول می‌شود. `a, b = "wtf!", "wtf!"` یک عبارت است. در حالی که `a = "wtf!"; b = "wtf!"` دو عبارت در یک خط است. به همین دلیل شناسه‌ها در `a = "wtf!"; b = "wtf!"` متفاوتند و همین‌طور وقتی با مفسر پایتون داخل فایل `some_file.py` اجرا می‌شوند، شناسه‌ها یکسانند.
+ تغییر ناگهانی در خروجی قطعه‌کد چهارم به دلیل [بهینه‌سازی پنجره‌ای](https://en.wikipedia.org/wiki/Peephole_optimization) است که تکنیکی معروف به جمع آوری ثابت‌ها است. به همین خاطر عبارت `'a'*20` با `'aaaaaaaaaaaaaaaaaaaa'` در هنگام کامپایل جایگزین می‌شود تا کمی بار از دوش چرخه‌ساعتی پردازنده کم شود. تکنیک جمع آوری ثابت‌ها فقط مخصوص رشته‌هایی با طول کمتر از 21 است. (چرا؟ فرض کنید که فایل `.pyc` که توسط کامپایلر ساخته می‌شود چقدر بزرگ می‌شد اگر عبارت `'a'*10**10`). [این](https://github.com/python/cpython/blob/3.6/Python/peephole.c#L288) هم کد پیاده‌سازی این تکنیک در CPython.
+ توجه: در پایتون ۳.۷، جمع آوری ثابت‌ها از بهینه‌ساز پنجره‌ای به بهینه‌ساز AST جدید انتقال داده شد همراه با تغییراتی در منطق آن. پس چهارمین قطعه‌کد در پایتون نسخه ۳.۷ کار نمی‌کند. شما می‌توانید در [اینجا](https://bugs.python.org/issue11549) بیشتر درمورد این تغییرات بخوانید.

---


### ▶ مراقب عملیات‌های زنجیره‌ای باشید
<!-- Example ID: 07974979-9c86-4720-80bd-467aa19470d9 --->
```py
>>> (False == False) in [False] # منطقیه
False
>>> False == (False in [False]) # منطقیه
False
>>> False == False in [False] # حالا چی؟
True

>>> True is False == False
False
>>> False is False is False
True

>>> 1 > 0 < 1
True
>>> (1 > 0) < 1
False
>>> 1 > (0 < 1)
False
```

#### 💡 توضیحات:

طبق https://docs.python.org/3/reference/expressions.html#comparisons
> اگر a، b، c، ...، y، z عبارت‌های عملیات و op1، op2، ...، opN عملگرهای عملیات باشند، آنگاه عملیات a op1 b op2 c ... y opN z معادل عملیات a op1 b and b op2 c and  ... y opN z است. فقط دقت کنید که هر عبارت یک بار ارزیابی می‌شود.

شاید چنین رفتاری برای شما احمقانه به نظر بیاد ولی برای عملیات‌هایی مثل `a == b == c` و `0 <= x <= 100` عالی عمل می‌کنه.

* عبارت `False is False is False` معادل عبارت `(False is False) and (False is False)` است
* عبارت `True is False == False` معادل عبارت `(True is False) and (False == False)` است و از آنجایی که قسمت اول این عبارت (`True is False`) پس از ارزیابی برابر با `False` می‌شود. پس کل عبارت معادل `False` می‌شود.
* عبارت `1 > 0 < 1` معادل عبارت `(1 > 0) and (0 < 1)` است.
* عبارت `(1 > 0) < 1` معادل عبارت `True < 1` است و :
  ```py
  >>> int(True)
  1
  >>> True + 1 # مربوط به این بخش نیست ولی همینجوری گذاشتم
  2
  ```
  پس عبارت `True < 1` معادل عبارت `1 < 1` می‌شود که در کل معادل `False` است.

---

### ▶ چطور از عملگر `is` استفاده نکنیم
<!-- Example ID: 230fa2ac-ab36-4ad1-b675-5f5a1c1a6217 --->
عبارت پایین خیلی معروفه و تو کل اینترنت موجوده.

1\.

```py
>>> a = 256
>>> b = 256
>>> a is b
True

>>> a = 257
>>> b = 257
>>> a is b
False
```

2\.

```py
>>> a = []
>>> b = []
>>> a is b
False

>>> a = tuple()
>>> b = tuple()
>>> a is b
True
```

3\.
**خروجی**

```py
>>> a, b = 257, 257
>>> a is b
True
```

**خروجی (مخصوص نسخه‌های (x).۳.۷)**

```py
>>> a, b = 257, 257
>>> a is b
False
```

#### 💡 توضیحات:

**فرض بین عملگرهای  `is` و `==`**

* عملگر `is` بررسی میکنه که دو متغیر در حافظه دستگاه به یک شیء اشاره میکنند یا نه (یعنی شناسه متغیرها رو با هم تطبیق میده).
* عملگر `==` مقدار متغیرها رو با هم مقایسه میکنه و یکسان بودنشون رو بررسی میکنه.
* پس `is` برای معادل بودن متغیرها در حافظه دستگاه و `==` برای معادل بودن مقادیر استفاده میشه. یه مثال برای شفاف سازی بیشتر:
  ```py
  >>> class A: pass
  >>> A() is A() # این‌ها دو شیء خالی هستند که در دو جای مختلف در حافظه قرار دارند.
  False
  ```

**عدد `256` از قبل تو حافظه قرار داده شده ولی `257` نه؟**

وقتی پایتون رو اجرا می‌کنید اعداد از `-5` تا `256` در حافظه ذخیره میشن. چون این اعداد خیلی پرکاربرد هستند پس منطقیه که اون‌ها رو در حافظه دستگاه، آماده داشته باشیم.

نقل قول از https://docs.python.org/3/c-api/long.html
> در پیاده سازی فعلی یک آرایه از اشیاء عددی صحیح برای تمام اعداد صحیح بین `-5` تا `256` نگه‌داری می‌شود. وقتی شما یک عدد صحیح در این بازه به مقداردهی می‌کنید، فقط یک ارجاع به آن عدد که از قبل در حافظه ذخیره شده است دریافت می‌کنید. پس تغییر مقدار عدد 1 باید ممکن باشد. که در این مورد من به رفتار پایتون شک دارم تعریف‌نشده است. :-)

```py
>>> id(256)
10922528
>>> a = 256
>>> b = 256
>>> id(a)
10922528
>>> id(b)
10922528
>>> id(257)
140084850247312
>>> x = 257
>>> y = 257
>>> id(x)
140084850247440
>>> id(y)
140084850247344
```

در اینجا مفسر وقتی عبارت `y = 257` رو اجرا میکنه، به اندازه کافی زیرکانه عمل نمیکنه که تشخیص بده که ما یک عدد صحیح با مقدار `257` در حافظه ذخیره کرده‌ایم، پس به ساختن یک شیء جدید در حافظه ادامه میده.

یک بهینه سازی مشابه شامل حال مقادیر **غیرقابل تغییر** دیگه مانند تاپل‌های خالی هم میشه. از اونجایی که لیست‌ها قابل تغییرند، عبارت `[] is []` مقدار `False` رو برمیگردونه و عبارت `() is ()` مقدار `True` رو برمیگردونه. به همین دلیله که قطعه کد دوم چنین رفتاری داره. بریم سراغ سومی.

**متغیرهای `a` و `b` وقتی در یک خط با مقادیر یکسانی مقداردهی میشن، هردو به یک شیء در حافظه اشاره میکنن**

**خروجی**

```py
>>> a, b = 257, 257
>>> id(a)
140640774013296
>>> id(b)
140640774013296
>>> a = 257
>>> b = 257
>>> id(a)
140640774013392
>>> id(b)
140640774013488
```

* وقتی a و b در یک خط با `257` مقداردهی میشن، مفسر پایتون یک شیء برای یکی از متغیرها در حافظه میسازه و متغیر دوم رو در حافظه به اون ارجاع میده. اگه این کار رو تو دو خط جدا از هم انجام بدید، درواقع مفسر پایتون از وجود مقدار `257` به عنوان یک شیء، "خبر نداره".

* این یک بهینه سازی توسط کامپایلر هست و مخصوصا در محیط تعاملی به کار برده میشه. وقتی شما دو خط رو در یک مفسر زنده وارد می‌کنید، اون‌ها به صورت جداگانه کامپایل میشن، به همین دلیل بهینه سازی به صورت جداگانه برای هرکدوم اعمال میشه. اگر بخواهید این مثال رو در یک فایل `.py` امتحان کنید، رفتار متفاوتی می‌بینید زیرا فایل به صورت کلی و یک‌جا کامپایل میشه. این بهینه سازی محدود به اعداد صحیح نیست و برای انواع داده‌های غیرقابل تغییر دیگه مانند رشته‌ها (مثال "رشته‌ها می‌توانند دردسرساز شوند" رو ببینید) و اعداد اعشاری هم اعمال میشه.

  ```py
  >>> a, b = 257.0, 257.0
  >>> a is b
  True
  ```

* چرا این برای پایتون ۳.۷ کار نکرد؟ دلیل انتزاعیش اینه که چنین بهینه‌سازی‌های کامپایلری وابسته به پیاده‌سازی هستن (یعنی بسته به نسخه، و نوع سیستم‌عامل و چیزهای دیگه تغییر میکنن). من هنوز پیگیرم که بدونم که کدوم تغییر تو پیاده‌سازی باعث همچین مشکلاتی میشه، می‌تونید برای خبرهای بیشتر این [موضوع](https://github.com/satwikkansal/wtfpython/issues/100) رو نگاه کنید.

---


### ▶ کلیدهای هش
<!-- Example ID: eb17db53-49fd-4b61-85d6-345c5ca213ff --->
1\.
```py
some_dict = {}
some_dict[5.5] = "JavaScript"
some_dict[5.0] = "Ruby"
some_dict[5] = "Python"
```

**Output:**

```py
>>> some_dict[5.5]
"JavaScript"
>>> some_dict[5.0] # رشته ("Python")، رشته ("Ruby") رو از بین برد؟
"Python"
>>> some_dict[5] 
"Python"

>>> complex_five = 5 + 0j
>>> type(complex_five)
complex
>>> some_dict[complex_five]
"Python"
```

خب، چرا Python همه جارو گرفت؟


#### 💡 توضیحات
* تو دیکشنری‌های پایتون چیزی که کلیدها رو یگانه میکنه مقدار کلیدهاست، نه شناسه اون‌ها. پس با اینکه `5`، `5.0` و `5 + 0j` شیءهای متمایزی از نوع‌های متفاوتی هستند ولی از اون جایی که مقدارشون با هم برابره، نمیتونن داخل یه `dict` به عنوان کلید جدا از هم باشن (حتی به عنوان مقادیر داخل یه `set` نمیتونن باشن). وقتی بخواید داخل یه دیکشنری جست‌وجو کنید، به محض اینکه یکی از این داده‌ها رو وارد کنید، مقدار نگاشته‌شده به کلیدی که مقدار برابر با اون داده داره ولی نوعش متفاوته، با موفقیت برگردونده میشه (به جای اینکه به ارور `KeyError` بردخورد کنید.).
  ```py
  >>> 5 == 5.0 == 5 + 0j
  True
  >>> 5 is not 5.0 is not 5 + 0j
  True
  >>> some_dict = {}
  >>> some_dict[5.0] = "Ruby"
  >>> 5.0 in some_dict
  True
  >>> (5 in some_dict) and (5 + 0j in some_dict)
  True
  ```
* همچنین این قانون برای مقداردهی توی دیکشنری هم اعمال میشه. وقتی شما عبارت `some_dict[5] = "Python"` رو اجرا می‌کنید، پایتون دنبال کلیدی با مقدار یکسان می‌گرده که اینجا ما داریم `5.0 -> "Ruby"` و مقدار نگاشته‌شده به این کلید در دیکشنری رو با مقدار جدید جایگزین میکنه و کلید رو همونجوری که هست باقی میذاره.
  ```py
  >>> some_dict
  {5.0: 'Ruby'}
  >>> some_dict[5] = "Python"
  >>> some_dict
  {5.0: 'Python'}
  ```
* خب پس چطوری میتونیم مقدار خود کلید رو به `5` تغییر بدیم (جای `5.0`)؟ راستش ما نمیتونیم این کار رو درجا انجام بدیم، ولی میتونیم اول اون کلید رو پاک کنیم (`del some_dict[5.0]`) و بعد کلیدی که میخوایم رو قرار بدیم (`some_dict[5]`) تا بتونیم عدد صحیح `5` رو به جای عدد اعشاری `5.0` به عنوان کلید داخل دیکشنری داشته باشیم. درکل خیلی کم پیش میاد که بخوایم چنین کاری کنیم.

* پایتون چطوری توی دیکشنری که کلید `5.0` رو داره، کلید `5` رو پیدا کرد؟ پایتون این کار رو توی زمان ثابتی توسط توابع هش انجام میده بدون اینکه مجبور باشه همه کلیدها رو بررسی کنه. وقتی پایتون دنبال کلیدی مثل `foo` داخل یه `dict` میگرده، اول مقدار `hash(foo)` رو محاسبه میکنه (که توی زمان ثابتی انجام میشه). از اونجایی که توی پایتون برای مقایسه برابری مقدار دو شیء لازمه که هش یکسانی هم داشته باشند ([مستندات](https://docs.python.org/3/reference/datamodel.html#object.__hash__)). `5`، `5.0` و `5 + 0j` مقدار هش یکسانی دارند.
  ```py
  >>> 5 == 5.0 == 5 + 0j
  True
  >>> hash(5) == hash(5.0) == hash(5 + 0j)
  True
  ```
  **توجه:** برعکس این قضیه لزوما درست نیست. شیءهای میتونن هش های یکسانی داشته باشند ولی مقادیر نابرابری داشته باشند. (این باعث به وجود اومدن پدیده‌ای معروف [تصادم هش]() میشه)، در این صورت توابع هش عملکرد خودشون رو کندتر از حالت عادی انجام می‌دهند.

---

### ▶ در عمق وجود همه ما یکسان هستیم
<!-- Example ID: 8f99a35f-1736-43e2-920d-3b78ec35da9b --->
```py
class WTF:
  pass
```

**Output:**
```py
>>> WTF() == WTF() # دو نمونه متفاوت از یک کلاس نمیتونند برابر هم باشند
False
>>> WTF() is WTF() # شناسه‌ها هم متفاوتند
False
>>> hash(WTF()) == hash(WTF()) # هش‌ها هم _باید_ متفاوت باشند
True
>>> id(WTF()) == id(WTF())
True
```

#### 💡 توضیحات:
* وقتی `id` صدا زده شد، پایتون یک شیء با کلاس `WTF` ساخت و اون رو به تابع `id` داد. تابع `id` شناسه این شیء رو میگیره (درواقع آدرس اون شیء در حافظه دستگاه) و شیء رو حذف میکنه.
* وقتی این کار رو دو بار متوالی انجام بدیم، پایتون آدرس یکسانی رو به شیء دوم اختصاص میده. از اونجایی که (در CPython) تابع `id` از آدرس شیءها توی حافظه به عنوان شناسه برای اون‌ها استفاده میکنه، پس شناسه این دو شیء یکسانه.
* پس، شناسه یک شیء تا زمانی که اون شیء وجود داره، منحصربه‌فرده. بعد از اینکه اون شیء حذف میشه یا قبل از اینکه اون شیء به وجود بیاد، چیز دیگه‌ای میتونه اون شناسه رو داشته باشه.
* ولی چرا با عملگر `is` مقدار `False` رو دریافت کردیم؟ بیاید با یه قطعه‌کد ببینیم دلیلش رو.
  ```py
  class WTF(object):
    def __init__(self): print("I")
    def __del__(self): print("D")
  ```

  **خروجی:**
  ```py
  >>> WTF() is WTF()
  I
  I
  D
  D
  False
  >>> id(WTF()) == id(WTF())
  I
  D
  I
  D
  True
  ```
  همونطور که مشاهده می‌کنید، ترتیب حذف شدن شیءها باعث تفاوت میشه.

---


### ▶ بی‌نظمی در خود نظم *
<!-- Example ID: 91bff1f8-541d-455a-9de4-6cd8ff00ea66 --->
```py
from collections import OrderedDict

dictionary = dict()
dictionary[1] = 'a'; dictionary[2] = 'b';

ordered_dict = OrderedDict()
ordered_dict[1] = 'a'; ordered_dict[2] = 'b';

another_ordered_dict = OrderedDict()
another_ordered_dict[2] = 'b'; another_ordered_dict[1] = 'a';

class DictWithHash(dict):
    """
    یک dict که تابع جادویی __hash__ هم توش پیاده شده.
    """
    __hash__ = lambda self: 0

class OrderedDictWithHash(OrderedDict):
    """
    یک OrderedDict که تابع جادویی __hash__ هم توش پیاده شده.
    """
    __hash__ = lambda self: 0
```

**Output**
```py
>>> dictionary == ordered_dict # اگر مقدار اولی با دومی برابره
True
>>> dictionary == another_ordered_dict # و مقدار اولی با سومی برابره
True
>>> ordered_dict == another_ordered_dict # پس چرا مقدار دومی با سومی برابر نیست؟
False

# ما همه‌مون میدونیم که یک مجموعه فقط شامل عناصر منحصربه‌فرد و غیرتکراریه.
# بیاید یک مجموعه از این دیکشنری‌ها بسازیم ببینیم چه اتفاقی میافته...

>>> len({dictionary, ordered_dict, another_ordered_dict})
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'dict'

# منطقیه چون dict ها __hash__ توشون پیاده‌سازی نشده. پس بیاید از
# کلاس‌هایی که خودمون درست کردیم استفاده کنیم.
>>> dictionary = DictWithHash()
>>> dictionary[1] = 'a'; dictionary[2] = 'b';
>>> ordered_dict = OrderedDictWithHash()
>>> ordered_dict[1] = 'a'; ordered_dict[2] = 'b';
>>> another_ordered_dict = OrderedDictWithHash()
>>> another_ordered_dict[2] = 'b'; another_ordered_dict[1] = 'a';
>>> len({dictionary, ordered_dict, another_ordered_dict})
1
>>> len({ordered_dict, another_ordered_dict, dictionary}) # ترتیب رو عوض می‌کنیم
2
```

چی شد؟

#### 💡 توضیحات:

- دلیل اینکه این مقایسه بین متغیرهای `dictionary`، `ordered_dict` و `another_ordered_dict` به درستی اجرا نمیشه به خاطر نحوه پیاده‌سازی تابع `__eq__` در کلاس `OrderedDict` هست. طبق [مستندات](https://docs.python.org/3/library/collections.html#ordereddict-objects)
    > مقایسه برابری بین شیءهایی از نوع OrderedDict به ترتیب اعضای آن‌ها هم بستگی دارد و به صورت `list(od1.items())==list(od2.items())` پیاده سازی شده است. مقایسه برابری بین شیءهای `OrderedDict` و شیءهای قابل نگاشت دیگر به ترتیب اعضای آن‌ها بستگی ندارد و مقایسه همانند دیکشنری‌های عادی انجام می‌شود.
- این رفتار باعث میشه که بتونیم `OrderedDict` ها رو هرجایی که یک دیکشنری عادی کاربرد داره، جایگزین کنیم و استفاده کنیم.
- خب، حالا چرا تغییر ترتیب روی طول مجموعه‌ای که از دیکشنری‌ها ساختیم، تاثیر گذاشت؟ جوابش همین رفتار مقایسه‌ای غیرانتقالی بین این شیءهاست. از اونجایی که `set` ها مجموعه‌ای از عناصر غیرتکراری و بدون نظم هستند، ترتیبی که عناصر تو این مجموعه‌ها درج میشن نباید مهم باشه. ولی در این مورد، مهم هست. بیاید کمی تجزیه و تحلیلش کنیم.
  ```py
    >>> some_set = set()
    >>> some_set.add(dictionary) # این شیء‌ها از قطعه‌کدهای بالا هستند.
    >>> ordered_dict in some_set
    True
    >>> some_set.add(ordered_dict)
    >>> len(some_set)
    1
    >>> another_ordered_dict in some_set
    True
    >>> some_set.add(another_ordered_dict)
    >>> len(some_set)
    1

    >>> another_set = set()
    >>> another_set.add(ordered_dict)
    >>> another_ordered_dict in another_set
    False
    >>> another_set.add(another_ordered_dict)
    >>> len(another_set)
    2
    >>> dictionary in another_set
    True
    >>> another_set.add(another_ordered_dict)
    >>> len(another_set)
    2
    ```
    پس بی‌ثباتی تو این رفتار به خاطر اینه که مقدار `another_ordered_dict in another_set` برابر با `False` هست چون `ordered_dict` از قبل داخل `another_set` هست و همونطور که قبلا مشاهده کردید، مقدار `ordered_dict == another_ordered_dict` برابر با `False` هست.

---


### ▶ تلاش کن... *
<!-- Example ID: b4349443-e89f-4d25-a109-82616be9d41a --->
```py
def some_func():
    try:
        return 'from_try'
    finally:
        return 'from_finally'

def another_func(): 
    for _ in range(3):
        try:
            continue
        finally:
            print("Finally!")

def one_more_func():
    try:
        for i in range(3):
            try:
                1 / i
            except ZeroDivisionError:
                # بذارید اینجا ارور بدیم و بیرون حلقه بهش
                # رسیدگی کنیم
                raise ZeroDivisionError("A trivial divide by zero error")
            finally:
                print("Iteration", i)
                break
    except ZeroDivisionError as e:
        print("Zero division error occurred", e)
```

**خروجی:**

```py
>>> some_func()
'from_finally'

>>> another_func()
Finally!
Finally!
Finally!

>>> 1 / 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero

>>> one_more_func()
Iteration 0

```

#### 💡 Explanation:

- وقتی یک عبارت `return`، `break` یا `continue` داخل بخش `try` از یک عبارت "try...finally" اجرا میشه، بخش `fianlly` هم هنگام خارج شدن اجرا میشه.
- مقدار بازگشتی یک تابع از طریق آخرین عبارت `return` که داخل تابع اجرا میشه، مشخص میشه. از اونجایی که بخش `finally` همیشه اجرا میشه، عبارت `return` که داخل بخش `finally` هست آخرین عبارتیه که اجرا میشه.
- نکته اینجاست که اگه بخش داخل بخش `finally` یک عبارت `return` یا `break` اجرا بشه، `exception` موقتی که ذخیره شده، رها میشه.

---


### ▶ برای چی?
<!-- Example ID: 64a9dccf-5083-4bc9-98aa-8aeecde4f210 --->
```py
some_string = "wtf"
some_dict = {}
for i, some_dict[i] in enumerate(some_string):
    i = 10
```

**Output:**
```py
>>> some_dict # یک دیکشنری مرتب‌شده نمایان میشه.
{0: 'w', 1: 't', 2: 'f'}
```

####  💡 توضیحات:
* یک حلقه `for` در [گرامر پایتون](https://docs.python.org/3/reference/grammar.html) این طور تعریف میشه:
  ```
  for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
  ```
  به طوری که `exprlist` یک هدف برای مقداردهیه. این یعنی، معادل عبارت `{exprlist} = {next_value}` **برای هر شیء داخل `testlist` اجرا می‌شود**.
  یک مثال جالب برای نشون دادن این تعریف:
  ```py
  for i in range(4):
      print(i)
      i = 10
  ```

  **خروجی:**
  ```
  0
  1
  2
  3
  ```

  آیا انتظار داشتید که حلقه فقط یک بار اجرا بشه؟

  **💡 توضیحات:**

  - عبارت مقداردهی `i = 10` به خاطر نحوه کار کردن حلقه‌ها، هیچوقت باعث تغییر در تکرار حلقه نمیشه. قبل از شروع هر تکرار، مقدار بعدی که توسط شیء قابل تکرار (که در اینجا `range(4)` است) ارائه میشه، از بسته خارج میشه و به متغیرهای لیست هدف (که در اینجا `i` است) مقداردهی میشه.

* تابع `enumerate(some_string)`، یک متغیر `i` (که یک شمارنده اقزایشی است) و یک حرف از حروف رشته `some_string` رو در هر تکرار برمیگردونه. و بعدش برای کلید `i` (تازه مقداردهی‌شده) در دیکشنری `some_dict`، مقدار اون حرف رو تنظیم می‌کنه. بازشده این حلقه می‌تونه مانند مثال زیر ساده بشه:
  ```py
  >>> i, some_dict[i] = (0, 'w')
  >>> i, some_dict[i] = (1, 't')
  >>> i, some_dict[i] = (2, 'f')
  >>> some_dict
  ```

---

### ▶ اختلاف زمانی در محاسبه
<!-- Example ID: 6aa11a4b-4cf1-467a-b43a-810731517e98 --->
1\.
```py
array = [1, 8, 15]
# یک عبارت تولیدکننده عادی
gen = (x for x in array if array.count(x) > 0)
array = [2, 8, 22]
```

**خروجی:**

```py
>>> print(list(gen)) # پس بقیه مقدارها کجا رفتن؟
[8]
```

2\.

```py
array_1 = [1,2,3,4]
gen_1 = (x for x in array_1)
array_1 = [1,2,3,4,5]

array_2 = [1,2,3,4]
gen_2 = (x for x in array_2)
array_2[:] = [1,2,3,4,5]
```

**خروجی:**
```py
>>> print(list(gen_1))
[1, 2, 3, 4]

>>> print(list(gen_2))
[1, 2, 3, 4, 5]
```

3\.

```py
array_3 = [1, 2, 3]
array_4 = [10, 20, 30]
gen = (i + j for i in array_3 for j in array_4)

array_3 = [4, 5, 6]
array_4 = [400, 500, 600]
```

**خروجی:**
```py
>>> print(list(gen))
[401, 501, 601, 402, 502, 602, 403, 503, 603]
```

#### 💡 توضیحات

- در یک عبارت [تولیدکننده](https://wiki.python.org/moin/Generators)، عبارت بند `in` در هنگام تعریف محاسبه میشه ولی عبارت شرطی در زمان اجرا محاسبه میشه.
- پس قبل از زمان اجرا، `array` دوباره با لیست `[2, 8, 22]` مقداردهی میشه و از آن‌جایی که در مقدار جدید `array`، بین `1`، `8` و `15`، فقط تعداد `8` بزرگتر از `0` است، تولیدکننده فقط مقدار `8` رو برمیگردونه
- تفاوت در مقدار `gen_1` و `gen_2` در بخش دوم به خاطر نحوه مقداردهی دوباره `array_1` و `array_2` است.
- در مورد اول، متغیر `array_1` به شیء جدید `[1,2,3,4,5]` وصله و از اون جایی که عبارت بند `in` در هنگام تعریف محاسبه میشه، `array_1` داخل تولیدکننده هنوز به شیء قدیمی `[1,2,3,4]` (که هنوز حذف نشده)
- در مورد دوم، مقداردهی برشی به `array_2` باعث به‌روز شدن شیء قدیمی این متغیر از `[1,2,3,4]` به `[1,2,3,4,5]` میشه و هر دو متغیر `gen_2` و `array_2` به یک شیء اشاره میکنند که حالا به‌روز شده.
- خیلی‌خب، حالا طبق منطقی که تا الان گفتیم، نباید مقدار `list(gen)` در قطعه‌کد سوم، `[11, 21, 31, 12, 22, 32, 13, 23, 33]` باشه؟ (چون `array_3` و `array_4` قراره درست مثل `array_1` رفتار کنن). دلیل این که چرا (فقط) مقادیر `array_4` به‌روز شدن، توی [PEP-289](https://www.python.org/dev/peps/pep-0289/#the-details) توضیح داده شده.

    > فقط بیرونی‌ترین عبارت حلقه `for` بلافاصله محاسبه میشه و باقی عبارت‌ها به تعویق انداخته میشن تا زمانی که تولیدکننده اجرا بشه.

---


### ▶ هر گردی، گردو نیست
<!-- Example ID: b26fb1ed-0c7d-4b9c-8c6d-94a58a055c0d --->
```py
>>> 'something' is not None
True
>>> 'something' is (not None)
False
```

#### 💡 توضیحات
- عملگر `is not` یک عملگر باینری واحده و رفتارش متفاوت تر از استفاده `is` و `not` به صورت جداگانه‌ست.
- عملگر `is not` مقدار `False` رو برمیگردونه اگر متغیرها در هردو سمت این عملگر به شیء یکسانی اشاره کنند و درغیر این صورت، مقدار `True` برمیگردونه
- در مثال بالا، عبارت `(not None)` برابره با مقدار `True` از اونجایی که مقدار `None` در زمینه boolean به `False` تبدیل میشه. پس کل عبارت معادل عبارت `'something' is True` میشه.

---
