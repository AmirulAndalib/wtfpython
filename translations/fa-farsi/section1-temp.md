## بخش: ذهن خود را به چالش بکشید!

### ▶ اول از همه! *

<!-- Example ID: d3d73936-3cf1-4632-b5ab-817981338863 -->
<!-- read-only -->

به دلایلی، عملگر "Walrus" (`:=`) که در نسخه ۳.۸ پایتون معرفی شد، خیلی محبوب شده. بیاید بررسیش کنیم.

1\.

```py
# Python version 3.8+

>>> a = "wtf_walrus"
>>> a
'wtf_walrus'

>>> a := "wtf_walrus"
File "<stdin>", line 1
    a := "wtf_walrus"
      ^
SyntaxError: invalid syntax

>>> (a := "wtf_walrus") # ولی این کار می‌کنه
'wtf_walrus'
>>> a
'wtf_walrus'
```

2 \.

```py
# Python version 3.8+

>>> a = 6, 9
>>> a
(6, 9)

>>> (a := 6, 9)
(6, 9)
>>> a
6

>>> a, b = 6, 9 # باز کردن معمولی
>>> a, b
(6, 9)
>>> (a, b = 16, 19) # آخ آخ
  File "<stdin>", line 1
    (a, b = 16, 19)
          ^
SyntaxError: invalid syntax

>>> (a, b := 16, 19) # این یه تاپل ۳تایی چاپ می‌کنه رو صفحه
(6, 16, 19)

>>> a # هنوز تغییر نکرده؟
6

>>> b
16
```



#### 💡 توضیحات

**مرور سریع بر عملگر Walrus**

عملگر Walrus همونطور که اشاره شد، در نسخه ۳.۸ پایتون معرفی
شد. این عملگر می‌تونه تو مقعیت‌هایی کاربردی باشه که شما می‌خواید داخل یه عبارت، مقادیری رو به متغیرها اختصاص بدید

```py
def some_func():
        # فرض کنید اینجا یک سری محاسبه سنگین انجام میشه
        # time.sleep(1000)
        return 5

# پس به جای اینکه این کارو بکنید:
if some_func():
        print(some_func()) # که خیلی راه نادرستیه چون محاسبه دوبار انجام میشه

# یا حتی این کارو کنید (که کار بدی هم نیست)
a = some_func()
if a:
    print(a)

# می‌تونید از این به بعد به طور مختصر بنویسید:
if a := some_func():
        print(a)

```

**خروجی (+۳.۸):**

```py
5
5
5
```

این باعث میشه که یک خط کمتر کد بزنیم و از دوبار فراخوندن `some_func` جلوگیری کرد.

- "عبارت اختصاص‌دادن مقدار" بدون پرانتز (نحوه استفاده عملگر Walrus)، در سطح بالا محدود است، `SyntaxError` در عبارت `a := "wtf_walrus"` در قطعه‌کد اول به همین دلیل است. قرار دادن آن داخل پرانتز، همانطور که می‌خواستیم کار کرد و مقدار را به `a` اختصاص داد.

- به طور معمول، قرار دادن عبارتی که دارای `=` است داخل پرانتز مجاز نیست. به همین دلیل ‍عبارت `(a, b = 6, 9)` به ما خطای سینتکس داد.

- قائده استفاده از عملگر Walrus به صورت `NAME:= expr` است، به طوری که `NAME` یک شناسه صحیح و `expr` یک عبارت صحیح است. به همین دلیل باز و بسته کردن با تکرار (iterable) پشتیبانی نمی‌شوند. پس،

  - عبارت `(a := 6, 9)` معادل عبارت `((a := 6), 9)` و در نهایت `(a, 9)` است. (که مقدار `a` عدد 6 است)

    ```py
    >>> (a := 6, 9) == ((a := 6), 9)
    True
    >>> x = (a := 696, 9)
    >>> x
    (696, 9)
    >>> x[0] is a # هر دو به یک مکان در حافظه دستگاه اشاره می‌کنند
    True
    ```

  - به طور مشابه، عبارت `(a, b := 16, 19)` معادل عبارت `(a, (b := 16), 19)` است که چیزی جز یک تاپل ۳تایی نیست.

---

### ▶ بعضی وقت‌ها رشته‌ها می‌توانند دردسرساز شوند

<!-- Example ID: 30f1d3fc-e267-4b30-84ef-4d9e7091ac1a --->
1\.

```py
>>> a = "some_string"
>>> id(a)
140420665652016
>>> id("some" + "_" + "string") # دقت کنید که هردو شناسه یکسانند.
140420665652016
```

2\.
```py
>>> a = "wtf"
>>> b = "wtf"
>>> a is b
True

>>> a = "wtf!"
>>> b = "wtf!"
>>> a is b
False

```

3\.

```py
>>> a, b = "wtf!", "wtf!"
>>> a is b # همه‌ی نسخه‌ها به جز 3.7.x
True

>>> a = "wtf!"; b = "wtf!"
>>> a is b # ممکن است True یا False باشد بسته به جایی که آن را اجرا می‌کنید (python shell / ipython / به‌صورت اسکریپت)
False
```

```py
# این بار در فایل some_file.py
a = "wtf!"
b = "wtf!"
print(a is b)

# موقع اجرای ماژول، True را چاپ می‌کند!
```

4\.

**خروجی (< Python3.7 )**

```py
>>> 'a' * 20 is 'aaaaaaaaaaaaaaaaaaaa'
True
>>> 'a' * 21 is 'aaaaaaaaaaaaaaaaaaaaa'
False
```

منطقیه، نه؟

#### 💡 توضیحات:
+ در قطعه‌کد اول و دوم، رفتار کد به دلیل یک بهینه سازی در CPython است (به نام داوطلب سازی رشته‌ها) که باعث می‌شود از برخی مقادیر غیرقابل تغییر، به جای مقداردهی مجدد، دوباره استفاده شود.
+ بیشتر متغیرهایی که به‌این صورت جایگزین می‌شوند، در حافظه دستگاه به مقدار داوطلب خود اشاره می‌کنند (تا از حافظه کمتری استفاده شود)
+ در قطعه‌کدهای بالا، رشته‌ها به‌صورت غیرمستقیم داوطلب می‌شوند. تصمیم اینکه رشته‌ها چه زمانی به صورت غیرمستقیم داوطلب شوند به نحوه پیاده‌سازی و مقداردهی آن‌ها بستگی دارد. برخی قوانین وجود دارند تا بتوانیم داوطلب شدن یا نشدن یک رشته را حدس بزنیم:
  * همه رشته‌ها با طول صفر یا یک داوطلب می‌شوند.
  * رشته‌ها در زمان کامپایل داوطلب می‌شوند (`'wtf'` داوطلب می‌شود اما `''.join(['w', 't', 'f'])` داوطلب نمی‌شود)
  * رشته‌هایی که از حروف ASCII ، اعداد صحیح و آندرلاین تشکیل نشده‌باشند داوطلب نمی‌شود. به همین دلیل `'wtf!'` به خاطر وجود `'!'` داوطلب نشد. پیاده‌سازی این قانون در CPython در [اینجا](https://github.com/python/cpython/blob/3.6/Objects/codeobject.c#L19) قرار دارد.

<p align="center">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="/images/string-intern/string_interning_dark_theme.svg">
      <source media="(prefers-color-scheme: light)" srcset="/images/string-intern/string_interning.svg">
      <img alt="Shows a string interning process." src="/images/string-intern/string_interning.svg">
    </picture>
</p>

+ زمانی که `"wtf!"` را در یک خط به `a` و `b` اختصاص می‌دهیم، مفسر پایتون شیء جدید می‌سازد و متغیر دوم را به آن ارجاع می‌دهد. اگر مقدار دهی در خط‌های جدا از هم انجام شود، در واقع مفسر "خبر ندارد" که یک شیء مختص به `"wtf!"` از قبل در برنامه وجود دارد (زیرا `"wtf!"` به دلایلی که در بالا گفته شد، به‌صورت غیرمستقیم داوطلب نمی‌شود). این بهینه سازی در زمان کامپایل انجام می‌شود. این بهینه سازی همچنین برای نسخه های (x).۳.۷ وجود ندارد (برای گفت‌وگوی بیشتر این [موضوع](https://github.com/satwikkansal/wtfpython/issues/100) را ببینید).
+ یک واحد کامپایل در یک محیط تعاملی مانند IPython از یک عبارت تشکیل می‌شود، در حالی که برای ماژول‌ها شامل کل ماژول می‌شود. `a, b = "wtf!", "wtf!"` یک عبارت است. در حالی که `a = "wtf!"; b = "wtf!"` دو عبارت در یک خط است. به همین دلیل شناسه‌ها در `a = "wtf!"; b = "wtf!"` متفاوتند و همین‌طور وقتی با مفسر پایتون داخل فایل `some_file.py` اجرا می‌شوند، شناسه‌ها یکسانند.
+ تغییر ناگهانی در خروجی قطعه‌کد چهارم به دلیل [بهینه‌سازی پنجره‌ای](https://en.wikipedia.org/wiki/Peephole_optimization) است که تکنیکی معروف به جمع آوری ثابت‌ها است. به همین خاطر عبارت `'a'*20` با `'aaaaaaaaaaaaaaaaaaaa'` در هنگام کامپایل جایگزین می‌شود تا کمی بار از دوش چرخه‌ساعتی پردازنده کم شود. تکنیک جمع آوری ثابت‌ها فقط مخصوص رشته‌هایی با طول کمتر از 21 است. (چرا؟ فرض کنید که فایل `.pyc` که توسط کامپایلر ساخته می‌شود چقدر بزرگ می‌شد اگر عبارت `'a'*10**10`). [این](https://github.com/python/cpython/blob/3.6/Python/peephole.c#L288) هم کد پیاده‌سازی این تکنیک در CPython.
+ توجه: در پایتون ۳.۷، جمع آوری ثابت‌ها از بهینه‌ساز پنجره‌ای به بهینه‌ساز AST جدید انتقال داده شد همراه با تغییراتی در منطق آن. پس چهارمین قطعه‌کد در پایتون نسخه ۳.۷ کار نمی‌کند. شما می‌توانید در [اینجا](https://bugs.python.org/issue11549) بیشتر درمورد این تغییرات بخوانید.

---


### ▶ مراقب عملیات‌های زنجیره‌ای باشید
<!-- Example ID: 07974979-9c86-4720-80bd-467aa19470d9 --->
```py
>>> (False == False) in [False] # منطقیه
False
>>> False == (False in [False]) # منطقیه
False
>>> False == False in [False] # حالا چی؟
True

>>> True is False == False
False
>>> False is False is False
True

>>> 1 > 0 < 1
True
>>> (1 > 0) < 1
False
>>> 1 > (0 < 1)
False
```

#### 💡 توضیحات:

طبق https://docs.python.org/3/reference/expressions.html#comparisons
> اگر a، b، c، ...، y، z عبارت‌های عملیات و op1، op2، ...، opN عملگرهای عملیات باشند، آنگاه عملیات a op1 b op2 c ... y opN z معادل عملیات a op1 b and b op2 c and  ... y opN z است. فقط دقت کنید که هر عبارت یک بار ارزیابی می‌شود.

شاید چنین رفتاری برای شما احمقانه به نظر بیاد ولی برای عملیات‌هایی مثل `a == b == c` و `0 <= x <= 100` عالی عمل می‌کنه.

* عبارت `False is False is False` معادل عبارت `(False is False) and (False is False)` است
* عبارت `True is False == False` معادل عبارت `(True is False) and (False == False)` است و از آنجایی که قسمت اول این عبارت (`True is False`) پس از ارزیابی برابر با `False` می‌شود. پس کل عبارت معادل `False` می‌شود.
* عبارت `1 > 0 < 1` معادل عبارت `(1 > 0) and (0 < 1)` است.
* عبارت `(1 > 0) < 1` معادل عبارت `True < 1` است و :
  ```py
  >>> int(True)
  1
  >>> True + 1 # مربوط به این بخش نیست ولی همینجوری گذاشتم
  2
  ```
  پس عبارت `True < 1` معادل عبارت `1 < 1` می‌شود که در کل معادل `False` است.

---

### ▶ چطور از عملگر `is` استفاده نکنیم
<!-- Example ID: 230fa2ac-ab36-4ad1-b675-5f5a1c1a6217 --->
عبارت پایین خیلی معروفه و تو کل اینترنت موجوده.

1\.

```py
>>> a = 256
>>> b = 256
>>> a is b
True

>>> a = 257
>>> b = 257
>>> a is b
False
```

2\.

```py
>>> a = []
>>> b = []
>>> a is b
False

>>> a = tuple()
>>> b = tuple()
>>> a is b
True
```

3\.
**خروجی**

```py
>>> a, b = 257, 257
>>> a is b
True
```

**خروجی (مخصوص نسخه‌های (x).۳.۷)**

```py
>>> a, b = 257, 257
>>> a is b
False
```

#### 💡 توضیحات:

**فرض بین عملگرهای  `is` و `==`**

* عملگر `is` بررسی میکنه که دو متغیر در حافظه دستگاه به یک شیء اشاره میکنند یا نه (یعنی شناسه متغیرها رو با هم تطبیق میده).
* عملگر `==` مقدار متغیرها رو با هم مقایسه میکنه و یکسان بودنشون رو بررسی میکنه.
* پس `is` برای معادل بودن متغیرها در حافظه دستگاه و `==` برای معادل بودن مقادیر استفاده میشه. یه مثال برای شفاف سازی بیشتر:
  ```py
  >>> class A: pass
  >>> A() is A() # این‌ها دو شیء خالی هستند که در دو جای مختلف در حافظه قرار دارند.
  False
  ```

**عدد `256` از قبل تو حافظه قرار داده شده ولی `257` نه؟**

وقتی پایتون رو اجرا می‌کنید اعداد از `-5` تا `256` در حافظه ذخیره میشن. چون این اعداد خیلی پرکاربرد هستند پس منطقیه که اون‌ها رو در حافظه دستگاه، آماده داشته باشیم.

نقل قول از https://docs.python.org/3/c-api/long.html
> در پیاده سازی فعلی یک آرایه از اشیاء عددی صحیح برای تمام اعداد صحیح بین `-5` تا `256` نگه‌داری می‌شود. وقتی شما یک عدد صحیح در این بازه به مقداردهی می‌کنید، فقط یک ارجاع به آن عدد که از قبل در حافظه ذخیره شده است دریافت می‌کنید. پس تغییر مقدار عدد 1 باید ممکن باشد. که در این مورد من به رفتار پایتون شک دارم تعریف‌نشده است. :-)

```py
>>> id(256)
10922528
>>> a = 256
>>> b = 256
>>> id(a)
10922528
>>> id(b)
10922528
>>> id(257)
140084850247312
>>> x = 257
>>> y = 257
>>> id(x)
140084850247440
>>> id(y)
140084850247344
```

در اینجا مفسر وقتی عبارت `y = 257` رو اجرا میکنه، به اندازه کافی زیرکانه عمل نمیکنه که تشخیص بده که ما یک عدد صحیح با مقدار `257` در حافظه ذخیره کرده‌ایم، پس به ساختن یک شیء جدید در حافظه ادامه میده.

یک بهینه سازی مشابه شامل حال مقادیر **غیرقابل تغییر** دیگه مانند تاپل‌های خالی هم میشه. از اونجایی که لیست‌ها قابل تغییرند، عبارت `[] is []` مقدار `False` رو برمیگردونه و عبارت `() is ()` مقدار `True` رو برمیگردونه. به همین دلیله که قطعه کد دوم چنین رفتاری داره. بریم سراغ سومی.

**متغیرهای `a` و `b` وقتی در یک خط با مقادیر یکسانی مقداردهی میشن، هردو به یک شیء در حافظه اشاره میکنن**

**خروجی**

```py
>>> a, b = 257, 257
>>> id(a)
140640774013296
>>> id(b)
140640774013296
>>> a = 257
>>> b = 257
>>> id(a)
140640774013392
>>> id(b)
140640774013488
```

* وقتی a و b در یک خط با `257` مقداردهی میشن، مفسر پایتون یک شیء برای یکی از متغیرها در حافظه میسازه و متغیر دوم رو در حافظه به اون ارجاع میده. اگه این کار رو تو دو خط جدا از هم انجام بدید، درواقع مفسر پایتون از وجود مقدار `257` به عنوان یک شیء، "خبر نداره".

* این یک بهینه سازی توسط کامپایلر هست و مخصوصا در محیط تعاملی به کار برده میشه. وقتی شما دو خط رو در یک مفسر زنده وارد می‌کنید، اون‌ها به صورت جداگانه کامپایل میشن، به همین دلیل بهینه سازی به صورت جداگانه برای هرکدوم اعمال میشه. اگر بخواهید این مثال رو در یک فایل `.py` امتحان کنید، رفتار متفاوتی می‌بینید زیرا فایل به صورت کلی و یک‌جا کامپایل میشه. این بهینه سازی محدود به اعداد صحیح نیست و برای انواع داده‌های غیرقابل تغییر دیگه مانند رشته‌ها (مثال "رشته‌ها می‌توانند دردسرساز شوند" رو ببینید) و اعداد اعشاری هم اعمال میشه.

  ```py
  >>> a, b = 257.0, 257.0
  >>> a is b
  True
  ```

* چرا این برای پایتون ۳.۷ کار نکرد؟ دلیل انتزاعیش اینه که چنین بهینه‌سازی‌های کامپایلری وابسته به پیاده‌سازی هستن (یعنی بسته به نسخه، و نوع سیستم‌عامل و چیزهای دیگه تغییر میکنن). من هنوز پیگیرم که بدونم که کدوم تغییر تو پیاده‌سازی باعث همچین مشکلاتی میشه، می‌تونید برای خبرهای بیشتر این [موضوع](https://github.com/satwikkansal/wtfpython/issues/100) رو نگاه کنید.

---


### ▶ کلیدهای هش
<!-- Example ID: eb17db53-49fd-4b61-85d6-345c5ca213ff --->
1\.
```py
some_dict = {}
some_dict[5.5] = "JavaScript"
some_dict[5.0] = "Ruby"
some_dict[5] = "Python"
```

**Output:**

```py
>>> some_dict[5.5]
"JavaScript"
>>> some_dict[5.0] # رشته ("Python")، رشته ("Ruby") رو از بین برد؟
"Python"
>>> some_dict[5] 
"Python"

>>> complex_five = 5 + 0j
>>> type(complex_five)
complex
>>> some_dict[complex_five]
"Python"
```

خب، چرا Python همه جارو گرفت؟


#### 💡 توضیحات
* تو دیکشنری‌های پایتون چیزی که کلیدها رو یگانه میکنه مقدار کلیدهاست، نه شناسه اون‌ها. پس با اینکه `5`، `5.0` و `5 + 0j` شیءهای متمایزی از نوع‌های متفاوتی هستند ولی از اون جایی که مقدارشون با هم برابره، نمیتونن داخل یه `dict` به عنوان کلید جدا از هم باشن (حتی به عنوان مقادیر داخل یه `set` نمیتونن باشن). وقتی بخواید داخل یه دیکشنری جست‌وجو کنید، به محض اینکه یکی از این داده‌ها رو وارد کنید، مقدار نگاشته‌شده به کلیدی که مقدار برابر با اون داده داره ولی نوعش متفاوته، با موفقیت برگردونده میشه (به جای اینکه به ارور `KeyError` بردخورد کنید.).
  ```py
  >>> 5 == 5.0 == 5 + 0j
  True
  >>> 5 is not 5.0 is not 5 + 0j
  True
  >>> some_dict = {}
  >>> some_dict[5.0] = "Ruby"
  >>> 5.0 in some_dict
  True
  >>> (5 in some_dict) and (5 + 0j in some_dict)
  True
  ```
* همچنین این قانون برای مقداردهی توی دیکشنری هم اعمال میشه. وقتی شما عبارت `some_dict[5] = "Python"` رو اجرا می‌کنید، پایتون دنبال کلیدی با مقدار یکسان می‌گرده که اینجا ما داریم `5.0 -> "Ruby"` و مقدار نگاشته‌شده به این کلید در دیکشنری رو با مقدار جدید جایگزین میکنه و کلید رو همونجوری که هست باقی میذاره.
  ```py
  >>> some_dict
  {5.0: 'Ruby'}
  >>> some_dict[5] = "Python"
  >>> some_dict
  {5.0: 'Python'}
  ```
* خب پس چطوری میتونیم مقدار خود کلید رو به `5` تغییر بدیم (جای `5.0`)؟ راستش ما نمیتونیم این کار رو درجا انجام بدیم، ولی میتونیم اول اون کلید رو پاک کنیم (`del some_dict[5.0]`) و بعد کلیدی که میخوایم رو قرار بدیم (`some_dict[5]`) تا بتونیم عدد صحیح `5` رو به جای عدد اعشاری `5.0` به عنوان کلید داخل دیکشنری داشته باشیم. درکل خیلی کم پیش میاد که بخوایم چنین کاری کنیم.

* پایتون چطوری توی دیکشنری که کلید `5.0` رو داره، کلید `5` رو پیدا کرد؟ پایتون این کار رو توی زمان ثابتی توسط توابع هش انجام میده بدون اینکه مجبور باشه همه کلیدها رو بررسی کنه. وقتی پایتون دنبال کلیدی مثل `foo` داخل یه `dict` میگرده، اول مقدار `hash(foo)` رو محاسبه میکنه (که توی زمان ثابتی انجام میشه). از اونجایی که توی پایتون برای مقایسه برابری مقدار دو شیء لازمه که هش یکسانی هم داشته باشند ([مستندات](https://docs.python.org/3/reference/datamodel.html#object.__hash__)). `5`، `5.0` و `5 + 0j` مقدار هش یکسانی دارند.
  ```py
  >>> 5 == 5.0 == 5 + 0j
  True
  >>> hash(5) == hash(5.0) == hash(5 + 0j)
  True
  ```
  **توجه:** برعکس این قضیه لزوما درست نیست. شیءهای میتونن هش های یکسانی داشته باشند ولی مقادیر نابرابری داشته باشند. (این باعث به وجود اومدن پدیده‌ای معروف [تصادم هش]() میشه)، در این صورت توابع هش عملکرد خودشون رو کندتر از حالت عادی انجام می‌دهند.

---

### ▶ در عمق وجود همه ما یکسان هستیم
<!-- Example ID: 8f99a35f-1736-43e2-920d-3b78ec35da9b --->
```py
class WTF:
  pass
```

**Output:**
```py
>>> WTF() == WTF() # دو نمونه متفاوت از یک کلاس نمیتونند برابر هم باشند
False
>>> WTF() is WTF() # شناسه‌ها هم متفاوتند
False
>>> hash(WTF()) == hash(WTF()) # هش‌ها هم _باید_ متفاوت باشند
True
>>> id(WTF()) == id(WTF())
True
```

#### 💡 توضیحات:
* وقتی `id` صدا زده شد، پایتون یک شیء با کلاس `WTF` ساخت و اون رو به تابع `id` داد. تابع `id` شناسه این شیء رو میگیره (درواقع آدرس اون شیء در حافظه دستگاه) و شیء رو حذف میکنه.
* وقتی این کار رو دو بار متوالی انجام بدیم، پایتون آدرس یکسانی رو به شیء دوم اختصاص میده. از اونجایی که (در CPython) تابع `id` از آدرس شیءها توی حافظه به عنوان شناسه برای اون‌ها استفاده میکنه، پس شناسه این دو شیء یکسانه.
* پس، شناسه یک شیء تا زمانی که اون شیء وجود داره، منحصربه‌فرده. بعد از اینکه اون شیء حذف میشه یا قبل از اینکه اون شیء به وجود بیاد، چیز دیگه‌ای میتونه اون شناسه رو داشته باشه.
* ولی چرا با عملگر `is` مقدار `False` رو دریافت کردیم؟ بیاید با یه قطعه‌کد ببینیم دلیلش رو.
  ```py
  class WTF(object):
    def __init__(self): print("I")
    def __del__(self): print("D")
  ```

  **خروجی:**
  ```py
  >>> WTF() is WTF()
  I
  I
  D
  D
  False
  >>> id(WTF()) == id(WTF())
  I
  D
  I
  D
  True
  ```
  همونطور که مشاهده می‌کنید، ترتیب حذف شدن شیءها باعث تفاوت میشه.

---
